import type { OpenAPIV3 } from 'openapi-types';
import type { Config } from './config';

export async function generateZodSchemas(
  schema: OpenAPIV3.Document,
  _config: Config,
): Promise<string> {
  const output: string[] = [];
  const schemaNames = new Set<string>();

  // Header
  output.push('// Auto-generated by @oats/gen - DO NOT EDIT');
  output.push(`// Generated: ${new Date().toISOString()}`);
  if (schema.info?.version) {
    output.push(`// API Version: ${schema.info.version}`);
  }
  output.push('');
  output.push("import { z } from 'zod';");
  output.push('');

  // Generate schemas for components
  if (schema.components?.schemas) {
    for (const [name, schemaData] of Object.entries(schema.components.schemas)) {
      schemaNames.add(name);
      output.push(...generateZodSchema(name, schemaData as OpenAPIV3.SchemaObject));
      output.push('');
    }
  }

  // Generate validators for each schema
  output.push('// Runtime validators');
  for (const name of schemaNames) {
    output.push(
      `export const validate${name} = (data: unknown): z.infer<typeof ${name}Schema> => {`,
    );
    output.push(`  return ${name}Schema.parse(data);`);
    output.push(`};`);
    output.push('');
  }

  // Generate safe validators that return Result type
  output.push('// Safe validators (return Result type)');
  for (const name of schemaNames) {
    output.push(`export const safeParse${name} = (data: unknown) => {`);
    output.push(`  return ${name}Schema.safeParse(data);`);
    output.push(`};`);
    output.push('');
  }

  // Type exports
  output.push('// Type exports');
  for (const name of schemaNames) {
    output.push(`export type ${name} = z.infer<typeof ${name}Schema>;`);
  }

  return output.join('\n');
}

function generateZodSchema(name: string, schema: OpenAPIV3.SchemaObject): string[] {
  const output: string[] = [];

  if (schema.type === 'object') {
    output.push(`export const ${name}Schema = z.object({`);

    if (schema.properties) {
      const properties = Object.entries(schema.properties).map(([prop, propSchema]) => {
        const schemaObj = propSchema as OpenAPIV3.SchemaObject;
        const zodType = schemaToZod(schemaObj);
        const isRequired = schema.required?.includes(prop);

        // Handle optional properties
        const finalZodType = isRequired ? zodType : `${zodType}.optional()`;

        return `  ${prop}: ${finalZodType}`;
      });

      output.push(properties.join(',\n'));
    }

    output.push('});');
  } else if (schema.enum) {
    // Handle enums
    const enumValues = schema.enum.map((v) => {
      if (typeof v === 'string') {
        return `z.literal('${v}')`;
      }
      return `z.literal(${v})`;
    });

    if (enumValues.length === 1) {
      output.push(`export const ${name}Schema = ${enumValues[0]};`);
    } else {
      output.push(`export const ${name}Schema = z.union([`);
      output.push('  ' + enumValues.join(',\n  '));
      output.push(']);');
    }
  } else if (schema.type === 'array') {
    const itemSchema = schema.items as OpenAPIV3.SchemaObject;
    const itemZod = schemaToZod(itemSchema);
    output.push(`export const ${name}Schema = z.array(${itemZod});`);
  } else {
    // Handle primitive types
    output.push(`export const ${name}Schema = ${schemaToZod(schema)};`);
  }

  return output;
}

function schemaToZod(schema: OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject): string {
  // Handle references
  if ('$ref' in schema) {
    const refName = schema.$ref.split('/').pop();
    return `${refName}Schema`;
  }

  // Handle arrays
  if (schema.type === 'array') {
    const items = schema.items as OpenAPIV3.SchemaObject;
    return `z.array(${schemaToZod(items)})`;
  }

  // Handle objects
  if (schema.type === 'object') {
    if (!schema.properties) {
      return 'z.record(z.unknown())';
    }

    const properties = Object.entries(schema.properties).map(([prop, propSchema]) => {
      const schemaObj = propSchema as OpenAPIV3.SchemaObject;
      const zodType = schemaToZod(schemaObj);
      const isRequired = schema.required?.includes(prop);
      const finalZodType = isRequired ? zodType : `${zodType}.optional()`;
      return `  ${prop}: ${finalZodType}`;
    });

    return `z.object({\n${properties.join(',\n')}\n})`;
  }

  // Handle string with format
  if (schema.type === 'string') {
    let zodString = 'z.string()';

    if (schema.format) {
      switch (schema.format) {
        case 'email':
          zodString += '.email()';
          break;
        case 'uuid':
          zodString += '.uuid()';
          break;
        case 'uri':
        case 'url':
          zodString += '.url()';
          break;
        case 'date-time':
          zodString += '.datetime()';
          break;
        case 'date':
          zodString += '.regex(/^\\d{4}-\\d{2}-\\d{2}$/)';
          break;
      }
    }

    if (schema.minLength) {
      zodString += `.min(${schema.minLength})`;
    }

    if (schema.maxLength) {
      zodString += `.max(${schema.maxLength})`;
    }

    if (schema.pattern) {
      zodString += `.regex(/${schema.pattern}/)`;
    }

    return zodString;
  }

  // Handle numbers
  if (schema.type === 'number' || schema.type === 'integer') {
    let zodNumber = schema.type === 'integer' ? 'z.number().int()' : 'z.number()';

    if (schema.minimum !== undefined) {
      zodNumber += `.min(${schema.minimum})`;
    }

    if (schema.maximum !== undefined) {
      zodNumber += `.max(${schema.maximum})`;
    }

    return zodNumber;
  }

  // Handle boolean
  if (schema.type === 'boolean') {
    return 'z.boolean()';
  }

  // Handle null
  if (schema.type === 'null') {
    return 'z.null()';
  }

  // Handle enums
  if (schema.enum) {
    const enumValues = schema.enum.map((v) => {
      if (typeof v === 'string') {
        return `z.literal('${v}')`;
      }
      return `z.literal(${v})`;
    });

    if (enumValues.length === 1) {
      return enumValues[0];
    }
    return `z.union([${enumValues.join(', ')}])`;
  }

  // Default case
  return 'z.unknown()';
}
