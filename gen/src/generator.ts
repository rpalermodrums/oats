import type { OpenAPIV3 } from 'openapi-types';
import type { Config } from './config';

export async function generateTypes(schema: OpenAPIV3.Document, config: Config): Promise<string> {
  const output: string[] = [];

  output.push('// Auto-generated by @oats/gen - DO NOT EDIT');
  output.push(`// Generated: ${new Date().toISOString()}`);
  if (schema.info?.version) {
    output.push(`// API Version: ${schema.info.version}`);
  }
  output.push('');

  output.push('export interface Paths {');

  for (const [path, pathItem] of Object.entries(schema.paths || {})) {
    output.push(`  "${path}": {`);

    for (const method of ['get', 'post', 'put', 'patch', 'delete'] as const) {
      const operation = (pathItem as any)?.[method];
      if (!operation) continue;

      output.push(`    ${method}: {`);

      if (operation.parameters) {
        output.push('      parameters: {');
        const pathParams = [];
        const queryParams = [];

        for (const param of operation.parameters) {
          if (param.in === 'path') {
            pathParams.push(`        ${param.name}: ${getTypeFromSchema(param.schema)};`);
          } else if (param.in === 'query') {
            const required = param.required ? '' : '?';
            queryParams.push(
              `        ${param.name}${required}: ${getTypeFromSchema(param.schema)};`,
            );
          }
        }

        if (pathParams.length) {
          output.push('        path: {');
          output.push(...pathParams);
          output.push('        };');
        }

        if (queryParams.length) {
          output.push('        query?: {');
          output.push(...queryParams);
          output.push('        };');
        }

        output.push('      };');
      }

      if (operation.requestBody) {
        const content = operation.requestBody.content?.['application/json'];
        if (content?.schema) {
          const typeName = getTypeFromSchema(content.schema);
          output.push(`      requestBody: {`);
          output.push(`        content: {`);
          output.push(`          "application/json": ${typeName};`);
          output.push(`        };`);
          output.push(`      };`);
        }
      }

      output.push('      responses: {');
      for (const [status, response] of Object.entries(operation.responses || {})) {
        const content = (response as any).content?.['application/json'];
        if (content?.schema) {
          const typeName = getTypeFromSchema(content.schema);
          output.push(`        ${status}: {`);
          output.push(`          content: {`);
          output.push(`            "application/json": ${typeName};`);
          output.push(`          };`);
          output.push(`        };`);
        }
      }
      output.push('      };');

      output.push(`    };`);
    }

    output.push('  };');
  }

  output.push('}');
  output.push('');

  if (schema.components?.schemas) {
    for (const [name, schemaData] of Object.entries(schema.components.schemas)) {
      output.push(...generateInterface(name, schemaData));
      output.push('');
    }
  }

  if (config.options?.includeHelpers !== false) {
    output.push(...generateHelpers());
  }

  return output.join('\n');
}

function generateInterface(name: string, schema: any): string[] {
  const output: string[] = [];

  if (schema.type === 'object') {
    output.push(`export interface ${name} {`);

    for (const [prop, propSchema] of Object.entries(schema.properties || {})) {
      const required = schema.required?.includes(prop) ? '' : '?';
      const type = getTypeFromSchema(propSchema);
      output.push(`  ${prop}${required}: ${type};`);
    }

    output.push('}');
  } else if (schema.enum) {
    const values = schema.enum.map((v: any) => `"${v}"`).join(' | ');
    output.push(`export type ${name} = ${values};`);
  } else {
    output.push(`export type ${name} = ${getTypeFromSchema(schema)};`);
  }

  return output;
}

function getTypeFromSchema(schema: any): string {
  if (!schema) return 'unknown';

  if (schema.$ref) {
    const name = schema.$ref.split('/').pop();
    return name || 'unknown';
  }

  if (schema.type === 'array') {
    return `${getTypeFromSchema(schema.items)}[]`;
  }

  const typeMap: Record<string, string> = {
    string: 'string',
    number: 'number',
    integer: 'number',
    boolean: 'boolean',
    object: 'Record<string, unknown>',
  };

  return typeMap[schema.type] || 'unknown';
}

function generateHelpers(): string[] {
  return [
    '// Type helpers',
    'export type ResponseBody<',
    '  P extends keyof Paths,',
    '  M extends keyof Paths[P],',
    '  S extends number = 200',
    '> = Paths[P][M] extends { responses: Record<S, { content: { "application/json": infer R } }> }',
    '  ? R',
    '  : never;',
    '',
    'export type RequestBody<',
    '  P extends keyof Paths,',
    '  M extends keyof Paths[P]',
    '> = Paths[P][M] extends { requestBody: { content: { "application/json": infer R } } }',
    '  ? R',
    '  : never;',
  ];
}
