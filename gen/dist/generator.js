"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateTypes = generateTypes;
async function generateTypes(schema, config) {
    const output = [];
    output.push('// Auto-generated by @oats/gen - DO NOT EDIT');
    output.push(`// Generated: ${new Date().toISOString()}`);
    if (schema.info?.version) {
        output.push(`// API Version: ${schema.info.version}`);
    }
    output.push('');
    output.push('export interface Paths {');
    for (const [path, pathItem] of Object.entries(schema.paths || {})) {
        output.push(`  "${path}": {`);
        for (const method of ['get', 'post', 'put', 'patch', 'delete']) {
            const operation = pathItem?.[method];
            if (!operation)
                continue;
            output.push(`    ${method}: {`);
            if (operation.parameters) {
                output.push('      parameters: {');
                const pathParams = [];
                const queryParams = [];
                for (const param of operation.parameters) {
                    if (param.in === 'path') {
                        pathParams.push(`        ${param.name}: ${getTypeFromSchema(param.schema)};`);
                    }
                    else if (param.in === 'query') {
                        const required = param.required ? '' : '?';
                        queryParams.push(`        ${param.name}${required}: ${getTypeFromSchema(param.schema)};`);
                    }
                }
                if (pathParams.length) {
                    output.push('        path: {');
                    output.push(...pathParams);
                    output.push('        };');
                }
                if (queryParams.length) {
                    output.push('        query?: {');
                    output.push(...queryParams);
                    output.push('        };');
                }
                output.push('      };');
            }
            if (operation.requestBody) {
                const content = operation.requestBody.content?.['application/json'];
                if (content?.schema) {
                    const typeName = getTypeFromSchema(content.schema);
                    output.push(`      requestBody: {`);
                    output.push(`        content: {`);
                    output.push(`          "application/json": ${typeName};`);
                    output.push(`        };`);
                    output.push(`      };`);
                }
            }
            output.push('      responses: {');
            for (const [status, response] of Object.entries(operation.responses || {})) {
                const content = response.content?.['application/json'];
                if (content?.schema) {
                    const typeName = getTypeFromSchema(content.schema);
                    output.push(`        ${status}: {`);
                    output.push(`          content: {`);
                    output.push(`            "application/json": ${typeName};`);
                    output.push(`          };`);
                    output.push(`        };`);
                }
            }
            output.push('      };');
            output.push(`    };`);
        }
        output.push('  };');
    }
    output.push('}');
    output.push('');
    if (schema.components?.schemas) {
        for (const [name, schemaData] of Object.entries(schema.components.schemas)) {
            output.push(...generateInterface(name, schemaData));
            output.push('');
        }
    }
    if (config.options?.includeHelpers !== false) {
        output.push(...generateHelpers());
    }
    return output.join('\n');
}
function generateInterface(name, schema) {
    const output = [];
    if (schema.type === 'object') {
        output.push(`export interface ${name} {`);
        for (const [prop, propSchema] of Object.entries(schema.properties || {})) {
            const required = schema.required?.includes(prop) ? '' : '?';
            const type = getTypeFromSchema(propSchema);
            output.push(`  ${prop}${required}: ${type};`);
        }
        output.push('}');
    }
    else if (schema.enum) {
        const values = schema.enum.map((v) => `"${v}"`).join(' | ');
        output.push(`export type ${name} = ${values};`);
    }
    else {
        output.push(`export type ${name} = ${getTypeFromSchema(schema)};`);
    }
    return output;
}
function getTypeFromSchema(schema) {
    if (!schema)
        return 'unknown';
    if (schema.$ref) {
        const name = schema.$ref.split('/').pop();
        return name || 'unknown';
    }
    if (schema.type === 'array') {
        return `${getTypeFromSchema(schema.items)}[]`;
    }
    const typeMap = {
        'string': 'string',
        'number': 'number',
        'integer': 'number',
        'boolean': 'boolean',
        'object': 'Record<string, unknown>'
    };
    return typeMap[schema.type] || 'unknown';
}
function generateHelpers() {
    return [
        '// Type helpers',
        'export type ResponseBody<',
        '  P extends keyof Paths,',
        '  M extends keyof Paths[P],',
        '  S extends number = 200',
        '> = Paths[P][M] extends { responses: Record<S, { content: { "application/json": infer R } }> }',
        '  ? R',
        '  : never;',
        '',
        'export type RequestBody<',
        '  P extends keyof Paths,',
        '  M extends keyof Paths[P]',
        '> = Paths[P][M] extends { requestBody: { content: { "application/json": infer R } } }',
        '  ? R',
        '  : never;'
    ];
}
//# sourceMappingURL=generator.js.map